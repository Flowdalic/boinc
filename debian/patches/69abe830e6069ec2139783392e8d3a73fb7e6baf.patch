## Description: add some description
## Origin/Author: add some origin or author
## Bug: bug URL
From 69abe830e6069ec2139783392e8d3a73fb7e6baf Mon Sep 17 00:00:00 2001
From: Preston Maness <aggroskater@gmail.com>
Date: Tue, 29 Dec 2015 20:59:23 -0600
Subject: [PATCH] Revamped the idle detection after pouring over documentation.
 This new code should be able to handle all local Xservers as they come and
 go. Issue with permitting access to Xservers from boinc user resolved (see
 comments; package managers may include appropriate file in
 /etc/X11/Xsession.d/, otherwise boinc ignores inaccessible DISPLAYs). Pushing
 for CI checks. Not finished though. This commit has generic debug output that
 would clutter the event log. I want to add a debug flag and only dump this
 (noisy, once-per-second) output if the user explicitly asks for it via
 configuration file.

---
 client/hostinfo_unix.cpp | 164 +++++++++++++++++++++++++++++++++++++----------
 1 file changed, 129 insertions(+), 35 deletions(-)

diff --git a/client/hostinfo_unix.cpp b/client/hostinfo_unix.cpp
index 5adc50e..1e20ad6 100644
--- a/client/hostinfo_unix.cpp
+++ b/client/hostinfo_unix.cpp
@@ -46,6 +46,8 @@
 // prevents naming collision between X.h define of Always and boinc's
 // lib/prefs.h definition in an enum.
 #undef Always
+#include <dirent.h> //for opening /tmp/.X11-unix/
+// (There is a DirScanner class in BOINC, but it doesn't do what we want)
 #endif
 
 #include <cstdio>
@@ -1956,59 +1958,151 @@ bool interrupts_idle(time_t t) {
 }
 
 #if HAVE_XSS
-// Ask the X server for user idle time (using XScreenSaver API)
-// Return true if the idle time exceeds idle_threshold.
+
+// Initializer for const vector<string> in xss_idle
 //
+const vector<string> X_display_values_initialize() {
+
+  /* According to "man Xserver", each local Xserver will have a socket file
+   * at /tmp/.X11-unix/Xn, where "n" is the display number (0, 1, 2, etc).
+   * We will parse this directory for currently open Xservers and attempt
+   * to ultimately query them for their idle time. If we can't open this
+   * directory, or the display_values vector is otherwise empty, then a
+   * static list of guesses for open display servers is utilized instead
+   * (DISPLAY values ":{0..6}") that will attempt connections to the first
+   * seven open Xservers.
+   *
+   * If we were unable to open _any_ Xserver, then we will log this and
+   * xss_idle returns true, effectively leaving idle detection up to other
+   * methods.
+   */
+  static const string dir = "/tmp/.X11-unix/";
+  vector<string> display_values;
+  vector<string>::iterator it;
+
+  DIR *dp;
+  struct dirent *dirp;
+  if((dp = opendir(dir.c_str())) == NULL) {
+    msg_printf(NULL, MSG_INFO, "Error (%d) opening %s.", errno, dir.c_str());
+  }
+
+  while ((dirp = readdir(dp)) != NULL) {
+    display_values.push_back(string(dirp->d_name));
+  }
+  closedir(dp);
+
+  // Get rid of non-matching elements and format the matching ones.
+  for ( it = display_values.begin() ; it != display_values.end() ; ) {
+    if ( it->c_str()[0] != 'X' ) {
+      it = display_values.erase(it);
+    }
+    else {
+      replace(it->begin(), it->end(), 'X', ':');
+      it++;
+    }
+
+  }
+
+  // if the display_values vector is empty, assume something went wrong
+  // (couldn't open directory, no apparent Xn files). Test a static list of
+  // DISPLAY values instead that is likely to catch most common use cases.
+  // (I don't know of many environments where there will simultaneously be
+  // more than seven active, local Xservers. I'm sure they exist... somewhere.
+  // But seven was the magic number for me).
+  if ( display_values.size() == 0 ) {
+    display_values.push_back(":0");
+    display_values.push_back(":1");
+    display_values.push_back(":2");
+    display_values.push_back(":3");
+    display_values.push_back(":4");
+    display_values.push_back(":5");
+    display_values.push_back(":6");
+    return display_values;
+  }
+  else {
+    return display_values;
+  }
+}
+
+/* Ask the X server for user idle time (using XScreenSaver API)
+ * Return true if the idle time exceeds idle_threshold for all accessible
+ * Xservers. However, if even one Xserver reports busy/non-idle, then
+ * return false. This function assumes that the boinc user has been
+ * granted access to the Xservers a la "xhost +SI:localuser:boinc". If
+ * access isn't available for an Xserver, then that Xserver is skipped.
+ * One may drop a file in /etc/X11/Xsession.d/ that runs the xhost command
+ * for all Xservers on a machine when the Xservers start up.
+ */
 bool xss_idle(long idle_threshold) {
-    static XScreenSaverInfo* xssInfo = NULL;
-    static Display* disp = NULL;
-    // if an X-related error occurs, set this to true and always
-    // report that we are idle (have xss_idle return true). Will report the
-    // failure in Event Log for user visibility.
-    static bool error = false;
-    
-    if (error) return true;
 
+  const vector<string> display_values = X_display_values_initialize();
+  vector<string>::const_iterator it;
+
+  static XScreenSaverInfo* xssInfo = XScreenSaverAllocInfo();
+  // This shouldn't fail. XScreenSaverAllocInfo just returns a small
+  // struct (see "man 3 xss"). If we can't allocate this, then we've
+  // got bigger problems to worry about.
+  if ( xssInfo == NULL ) {
+    msg_printf(NULL, MSG_INFO,
+      "XScreenSaverAllocInfo failed. Out of memory? Skipping XScreenSaver idle detection.");
+    return true;
+  }
+
+  for (it = display_values.begin() ; it != display_values.end() ; it++) {
+
+    Display* disp = NULL;
     long idle_time = 0;
     
+    disp = XOpenDisplay(it->c_str());
+    // XOpenDisplay may return NULL if there is no running X
+    // or DISPLAY points to wrong/invalid display
     if (disp == NULL) {
-        disp = XOpenDisplay(NULL);
-        // XOpenDisplay may return NULL if there is no running X
-        // or DISPLAY points to wrong/invalid display
-        //
-        if (disp == NULL) {
-            error = true;
-            msg_printf(NULL, MSG_INFO, "XDisplay not found. X-based idle detection disabled.");
-            return true;
-        }
-        int event_base_return, error_base_return;
-        xssInfo = XScreenSaverAllocInfo();
-        if (!XScreenSaverQueryExtension(
-            disp, &event_base_return, &error_base_return
-        )){
-            error = true;
-            msg_printf(NULL, MSG_INFO, "XScreenSaverQueryExtension() failed. X-based idle detection disabled.");
-            return true;
-        }
+      msg_printf(NULL, MSG_INFO, 
+      "DISPLAY '%s' not found or insufficient access.",
+      it->c_str());
+      continue;
     }
 
+    // Determine if the DISPLAY we have accessed has the XScreenSaver
+    // extension or not.
+    int event_base_return, error_base_return;
+    if (!XScreenSaverQueryExtension(
+      disp, &event_base_return, &error_base_return
+    )){
+      msg_printf(NULL, MSG_INFO,
+        "XScreenSaver extension not available for DISPLAY '%s'.",
+        it->c_str());
+      continue;
+    }
+
+    // All checks passed. Get the idle information.
     XScreenSaverQueryInfo(disp, DefaultRootWindow(disp), xssInfo);
     idle_time = xssInfo->idle;
 
     // convert from milliseconds to seconds
-    //
     idle_time = idle_time / 1000;
 
-    //msg_printf(NULL, MSG_INFO, "XSS idle detection succeeded.");
-    //msg_printf(NULL, MSG_INFO, "idle threshold: %ld", idle_threshold);
-    //msg_printf(NULL, MSG_INFO, "idle_time: %ld", idle_time);
+    msg_printf(NULL, MSG_INFO, "XSS idle detection succeeded on DISPLAY '%s'.", it->c_str());
+    msg_printf(NULL, MSG_INFO, "idle threshold: %ld", idle_threshold);
+    msg_printf(NULL, MSG_INFO, "idle_time: %ld", idle_time);
 
     if ( idle_threshold < idle_time ) {
-        //msg_printf(NULL, MSG_INFO, "System is idle according to X.");
+      msg_printf(NULL, MSG_INFO, "DISPLAY '%s' is idle.", it->c_str());
     } else {
-        //msg_printf(NULL, MSG_INFO, "System is active according to X.");
+      msg_printf(NULL, MSG_INFO, "DISPLAY '%s' is active.", it->c_str());
+      return false;
     }
-    return idle_threshold < idle_time;
+
+  }
+
+  /* We should only ever get here if all Xservers (that were queryable) were
+   * idle. If none of the Xservers were queryable, we should still end up here,
+   * and simply report true. In that case, the xss_idle function effectively
+   * provides no information on the idle state of the system, as no Xservers
+   * were accessible to interrogate.
+   */
+  return true;
+
 }
 #endif // HAVE_XSS
 
