From e965ea2e32d467e6937f206c96270cabd381df6e Mon Sep 17 00:00:00 2001
From: Christian Beer <christian.beer@aei.mpg.de>
Date: Mon, 27 Jun 2016 18:26:27 +0200
Subject: [PATCH] Lib: build against openSSL 1.1.0

The upcoming OpenSSL version introduces some API changes (https://wiki.openssl.org/index.php/1.1_API_Changes). In BOINC mainly code related to RSA keys is affected for now.

Contributed by: Gianfranco Costamagna
---
 lib/crypt.cpp      | 115 ++++++++++++++++++++++++++++++++++++++++++++++++++++-
 lib/crypt.h        |   5 +++
 lib/crypt_prog.cpp |  12 ++++++
 3 files changed, 131 insertions(+), 1 deletion(-)

diff --git a/lib/crypt.cpp b/lib/crypt.cpp
index 192bbc2..cd6f04a 100644
--- a/lib/crypt.cpp
+++ b/lib/crypt.cpp
@@ -453,7 +453,7 @@ int read_key_file(const char* keyfile, R_RSA_PRIVATE_KEY& key) {
     return 0;
 }
 
-static void bn_to_bin(BIGNUM* bn, unsigned char* bin, int n) {
+static void bn_to_bin(const BIGNUM* bn, unsigned char* bin, int n) {
     memset(bin, 0, n);
     int m = BN_num_bytes(bn);
     BN_bn2bin(bn, bin+n-m);
@@ -463,11 +463,38 @@ void openssl_to_keys(
     RSA* rp, int nbits, R_RSA_PRIVATE_KEY& priv, R_RSA_PUBLIC_KEY& pub
 ) {
     pub.bits = nbits;
+#ifdef HAVE_OPAQUE_RSA_DSA_DH
+    BIGNUM *n;
+    BIGNUM *e;
+    BIGNUM *d;
+    BIGNUM *p;
+    BIGNUM *q;
+    BIGNUM *dmp1;
+    BIGNUM *dmq1;
+    BIGNUM *iqmp;
+    RSA_get0_key(rp, &n, &e, &d);
+    RSA_get0_factors(rp, &p, &q);
+    RSA_get0_crt_params(rp, &dmp1, &dmq1, &iqmp);
+
+    bn_to_bin(n, pub.modulus, sizeof(pub.modulus));
+    bn_to_bin(e, pub.exponent, sizeof(pub.exponent));
+#else
     bn_to_bin(rp->n, pub.modulus, sizeof(pub.modulus));
     bn_to_bin(rp->e, pub.exponent, sizeof(pub.exponent));
+#endif
 
     memset(&priv, 0, sizeof(priv));
     priv.bits = nbits;
+#ifdef HAVE_OPAQUE_RSA_DSA_DH
+    bn_to_bin(n, priv.modulus, sizeof(priv.modulus));
+    bn_to_bin(e, priv.publicExponent, sizeof(priv.publicExponent));
+    bn_to_bin(d, priv.exponent, sizeof(priv.exponent));
+    bn_to_bin(p, priv.prime[0], sizeof(priv.prime[0]));
+    bn_to_bin(q, priv.prime[1], sizeof(priv.prime[1]));
+    bn_to_bin(dmp1, priv.primeExponent[0], sizeof(priv.primeExponent[0]));
+    bn_to_bin(dmq1, priv.primeExponent[1], sizeof(priv.primeExponent[1]));
+    bn_to_bin(iqmp, priv.coefficient, sizeof(priv.coefficient));
+#else
     bn_to_bin(rp->n, priv.modulus, sizeof(priv.modulus));
     bn_to_bin(rp->e, priv.publicExponent, sizeof(priv.publicExponent));
     bn_to_bin(rp->d, priv.exponent, sizeof(priv.exponent));
@@ -476,9 +503,32 @@ void openssl_to_keys(
     bn_to_bin(rp->dmp1, priv.primeExponent[0], sizeof(priv.primeExponent[0]));
     bn_to_bin(rp->dmq1, priv.primeExponent[1], sizeof(priv.primeExponent[1]));
     bn_to_bin(rp->iqmp, priv.coefficient, sizeof(priv.coefficient));
+#endif
 }
 
 void private_to_openssl(R_RSA_PRIVATE_KEY& priv, RSA* rp) {
+#ifdef HAVE_OPAQUE_RSA_DSA_DH
+    BIGNUM *n;
+    BIGNUM *e;
+    BIGNUM *d;
+    BIGNUM *p;
+    BIGNUM *q;
+    BIGNUM *dmp1;
+    BIGNUM *dmq1;
+    BIGNUM *iqmp;
+
+    n = BN_bin2bn(priv.modulus, sizeof(priv.modulus), 0);
+    e = BN_bin2bn(priv.publicExponent, sizeof(priv.publicExponent), 0);
+    d = BN_bin2bn(priv.exponent, sizeof(priv.exponent), 0);
+    p = BN_bin2bn(priv.prime[0], sizeof(priv.prime[0]), 0);
+    q = BN_bin2bn(priv.prime[1], sizeof(priv.prime[1]), 0);
+    dmp1 = BN_bin2bn(priv.primeExponent[0], sizeof(priv.primeExponent[0]), 0);
+    dmq1 = BN_bin2bn(priv.primeExponent[1], sizeof(priv.primeExponent[1]), 0);
+    iqmp = BN_bin2bn(priv.coefficient, sizeof(priv.coefficient), 0);
+    RSA_set0_key(rp, n, e, d);
+    RSA_set0_factors(rp, p, q);
+    RSA_set0_crt_params(rp, dmp1, dmq1, iqmp);
+#else
     rp->n = BN_bin2bn(priv.modulus, sizeof(priv.modulus), 0);
     rp->e = BN_bin2bn(priv.publicExponent, sizeof(priv.publicExponent), 0);
     rp->d = BN_bin2bn(priv.exponent, sizeof(priv.exponent), 0);
@@ -487,11 +537,22 @@ void private_to_openssl(R_RSA_PRIVATE_KEY& priv, RSA* rp) {
     rp->dmp1 = BN_bin2bn(priv.primeExponent[0], sizeof(priv.primeExponent[0]), 0);
     rp->dmq1 = BN_bin2bn(priv.primeExponent[1], sizeof(priv.primeExponent[1]), 0);
     rp->iqmp = BN_bin2bn(priv.coefficient, sizeof(priv.coefficient), 0);
+#endif
 }
 
 void public_to_openssl(R_RSA_PUBLIC_KEY& pub, RSA* rp) {
+#ifdef HAVE_OPAQUE_RSA_DSA_DH
+    BIGNUM *n;
+    BIGNUM *e;
+    BIGNUM *d;
+    n = BN_bin2bn(pub.modulus, sizeof(pub.modulus), 0);
+    e = BN_bin2bn(pub.exponent, sizeof(pub.exponent), 0);
+    // d??? FIXME
+    RSA_set0_key(rp, n, e, d);
+#else
     rp->n = BN_bin2bn(pub.modulus, sizeof(pub.modulus), 0);
     rp->e = BN_bin2bn(pub.exponent, sizeof(pub.exponent), 0);
+#endif
 }
 
 static int _bn2bin(BIGNUM *from, unsigned char *to, int max) {
@@ -507,6 +568,38 @@ static int _bn2bin(BIGNUM *from, unsigned char *to, int max) {
 }
 
 int openssl_to_private(RSA *from, R_RSA_PRIVATE_KEY *to) {
+#ifdef HAVE_OPAQUE_RSA_DSA_DH
+    BIGNUM *n;
+    BIGNUM *e;
+    BIGNUM *d;
+    BIGNUM *p;
+    BIGNUM *q;
+    BIGNUM *dmp1;
+    BIGNUM *dmq1;
+    BIGNUM *iqmp;
+
+    RSA_get0_key(from, &n, &e, &d);
+    RSA_get0_factors(from, &p, &q);
+    RSA_get0_crt_params(from, &dmp1, &dmq1, &iqmp);
+
+    to->bits = BN_num_bits(n);
+    if (!_bn2bin(n,to->modulus,MAX_RSA_MODULUS_LEN))
+        return(0);
+    if (!_bn2bin(e,to->publicExponent,MAX_RSA_MODULUS_LEN))
+        return(0);
+    if (!_bn2bin(d,to->exponent,MAX_RSA_MODULUS_LEN))
+        return(0);
+    if (!_bn2bin(p,to->prime[0],MAX_RSA_PRIME_LEN))
+        return(0);
+    if (!_bn2bin(q,to->prime[1],MAX_RSA_PRIME_LEN))
+        return(0);
+    if (!_bn2bin(dmp1,to->primeExponent[0],MAX_RSA_PRIME_LEN))
+        return(0);
+    if (!_bn2bin(dmq1,to->primeExponent[1],MAX_RSA_PRIME_LEN))
+        return(0);
+    if (!_bn2bin(iqmp,to->coefficient,MAX_RSA_PRIME_LEN))
+        return(0);
+#else
 	to->bits = BN_num_bits(from->n);
 	if (!_bn2bin(from->n,to->modulus,MAX_RSA_MODULUS_LEN)) 
 	    return(0);
@@ -524,6 +617,7 @@ int openssl_to_private(RSA *from, R_RSA_PRIVATE_KEY *to) {
 	    return(0);
 	if (!_bn2bin(from->iqmp,to->coefficient,MAX_RSA_PRIME_LEN)) 
 	    return(0);
+#endif
     return 1;
 }
 
@@ -569,7 +663,11 @@ int check_validity_of_cert(
         BIO_vfree(bio);
         return 0;
     }
+#ifdef HAVE_OPAQUE_EVP_PKEY
+    if (EVP_PKEY_id(pubKey) == EVP_PKEY_RSA) {
+#else
     if (pubKey->type == EVP_PKEY_RSA) {
+#endif
         BN_CTX *c = BN_CTX_new();
         if (!c) {
 	        X509_free(cert);
@@ -577,18 +675,33 @@ int check_validity_of_cert(
 	        BIO_vfree(bio);
 	        return 0;
 	    }
+#ifdef HAVE_OPAQUE_RSA_DSA_DH
+        RSA *rsa;
+        rsa = EVP_PKEY_get0_RSA(pubKey);
+        if (!RSA_blinding_on(rsa, c)) {
+#else
 	    if (!RSA_blinding_on(pubKey->pkey.rsa, c)) {
+#endif
 	        X509_free(cert);
 	        EVP_PKEY_free(pubKey);
 	        BIO_vfree(bio);
 	        BN_CTX_free(c);
 	        return 0;
 	    }
+#ifdef HAVE_OPAQUE_RSA_DSA_DH
+        retval = RSA_verify(NID_md5, md5_md, MD5_DIGEST_LENGTH, sfileMsg, sfsize, rsa);
+        RSA_blinding_off(rsa);
+#else
 	    retval = RSA_verify(NID_md5, md5_md, MD5_DIGEST_LENGTH, sfileMsg, sfsize, pubKey->pkey.rsa);
 	    RSA_blinding_off(pubKey->pkey.rsa);
+#endif
 	    BN_CTX_free(c);
     }
+#ifdef HAVE_OPAQUE_EVP_PKEY
+    if (EVP_PKEY_id(pubKey) == EVP_PKEY_DSA) {
+#else
     if (pubKey->type == EVP_PKEY_DSA) {
+#endif
         fprintf(stderr,
             "%s: ERROR: DSA keys are not supported.\n",
             time_to_string(dtime())
diff --git a/lib/crypt.h b/lib/crypt.h
index 022bd2a..33c62a8 100644
--- a/lib/crypt.h
+++ b/lib/crypt.h
@@ -26,6 +26,11 @@
 
 #include <openssl/rsa.h>
 
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) /* OpenSSL 1.1.0+ */
+#define HAVE_OPAQUE_EVP_PKEY 1 /* since 1.1.0 -pre3 */
+#define HAVE_OPAQUE_RSA_DSA_DH 1 /* since 1.1.0 -pre5 */
+#endif
+
 #define MAX_RSA_MODULUS_BITS 1024
 #define MAX_RSA_MODULUS_LEN ((MAX_RSA_MODULUS_BITS + 7) / 8)
 #define MAX_RSA_PRIME_BITS ((MAX_RSA_MODULUS_BITS + 1) / 2)
diff --git a/lib/crypt_prog.cpp b/lib/crypt_prog.cpp
index 2a1eb5d..3bc2d53 100644
--- a/lib/crypt_prog.cpp
+++ b/lib/crypt_prog.cpp
@@ -125,7 +125,11 @@ int main(int argc, char** argv) {
     unsigned char signature_buf[256], buf[256], buf2[256];
     FILE *f, *fpriv, *fpub;
     char cbuf[256];
+#ifdef HAVE_OPAQUE_RSA_DSA_DH
+    RSA *rsa_key;
+#else
     RSA rsa_key;
+#endif
     RSA *rsa_key_;
 	BIO *bio_out=NULL;
     BIO *bio_err=NULL;
@@ -339,7 +343,11 @@ int main(int argc, char** argv) {
                 retval = scan_key_hex(fpriv, (KEY*)&private_key, sizeof(private_key));
                 fclose(fpriv);
                 if (retval) die("scan_key_hex\n");
+#ifdef HAVE_OPAQUE_RSA_DSA_DH
+                private_to_openssl(private_key, rsa_key);
+#else
                 private_to_openssl(private_key, &rsa_key);
+#endif
 
                 //i = PEM_write_bio_RSAPrivateKey(bio_out, &rsa_key,
         		//				enc, NULL, 0, pass_cb, NULL);
@@ -349,7 +357,11 @@ int main(int argc, char** argv) {
         		//				NULL, NULL, 0, pass_cb, NULL);
                 fpriv = fopen(argv[5], "w+");
                 if (!fpriv) die("fopen");
+#ifdef HAVE_OPAQUE_RSA_DSA_DH
+                PEM_write_RSAPrivateKey(fpriv, rsa_key, NULL, NULL, 0, 0, NULL);
+#else
                 PEM_write_RSAPrivateKey(fpriv, &rsa_key, NULL, NULL, 0, 0, NULL);
+#endif
                 fclose(fpriv);
     		    //if (i == 0) {
                 //    ERR_print_errors(bio_err);
